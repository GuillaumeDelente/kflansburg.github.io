<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Streaming on kflansburg.com</title>
    <link>https://kflansburg.com/tags/streaming/</link>
    <description>Recent content in Streaming on kflansburg.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Kevin Flansburg</copyright>
    <lastBuildDate>Sat, 27 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://kflansburg.com/tags/streaming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Failure Modes</title>
      <link>https://kflansburg.com/posts/ordered-stateful-streaming/failure-modes/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/ordered-stateful-streaming/failure-modes/</guid>
      <description>&lt;p&gt;In the fourth post of this series I will outline several sources of failure in
streaming applications. In each case I discuss the potential for data loss and
possible mitigations. This analysis can drive decisions on the tradeoff between
infrastructure costs and the upper bound on data loss.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Operating Pipelines</title>
      <link>https://kflansburg.com/posts/ordered-stateful-streaming/operating-pipelines/</link>
      <pubDate>Sat, 27 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/ordered-stateful-streaming/operating-pipelines/</guid>
      <description>&lt;p&gt;In the third post of this series I will share operational and practical issues
that I have encountered when developing and hosting long-running Spark
streaming applications. This includes tips that will be useful to those who are
first starting out with Scala and Spark, as well as insights on performance and
reliability that will be useful to those who are more experienced.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Selecting a Framework</title>
      <link>https://kflansburg.com/posts/ordered-stateful-streaming/selecting-a-framework/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/ordered-stateful-streaming/selecting-a-framework/</guid>
      <description>&lt;p&gt;In the second post of this series I explore the strengths and weaknesses of
several popular streaming frameworks. This analysis was performed a couple of
years ago with a particular application in mind. These frameworks have since
improved, but this post should provide some insight into the tradeoffs and
decisions involved when designing streaming applications, and lessons can be
learned from choices that did and did not pay off.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://kflansburg.com/posts/ordered-stateful-streaming/introduction/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kflansburg.com/posts/ordered-stateful-streaming/introduction/</guid>
      <description>&lt;p&gt;I recently spent two weeks tracking down a subtle bug in a Spark Structured
Streaming application which I have been maintaining for several years. Having
dealt with many such time-consuming bugs over the years, I&amp;rsquo;ve decided to
compile my experiences working with ordered, stateful streaming applications
into a series of posts. This series will serve as an introductory guide to the
design and operation of stateful streaming pipelines, and hopefully spur some
further development to simplify this process in the future.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
